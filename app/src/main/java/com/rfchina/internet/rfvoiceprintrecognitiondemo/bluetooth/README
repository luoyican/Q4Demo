❤❤ ❤ 写在前面❤ ❤ ❤ 因为我本身就是一个小白，而此文也只是对我自己学习的一个总结并不是什么技术分析共享文章，所以可能有很多理解有误的地方，要是大神们看到了还请不吝指教，不接受无脑喷。

     奈何公司要求，脑子不好使的选了个蜜汁课题——蓝牙身份识别，想法很简单，就是通过蓝牙进行身份识别，场景就是门禁。在进行这个方面的学习之前，我对蓝牙的了解完全就停留在应用层面，对于原理的认知为0。
     因为完全的无知，加之自己基础之烂，意味着接下来我所要经历的日子将会是苦逼加无奈，虽然痛但最后的最后还是在死循环中找到了一个解决方法，也算是对自己这两个月来的付出做的一个交代吧。
     废话不多说，接下来就是记录这段时间关于蓝牙开发的一个心路历程。因为我做的是android，一开始并没有想过要兼容ios的问题，也正是因为这种想法累人累己，所以还是得有全局观（老板不会发钱给你搞一些不可能铺开的技术研究）。基于这种情况，我就不管三七二十一的，直接在网上搜索各种资料，android蓝牙连接什么的，也总算是对蓝牙有了一定的认知了，也为后续的开发起到了帮助。

一、经典蓝牙模式
     前面说了，我只做android的研究，所以在网上直接搜到的都是经典蓝牙模式,网上的资料也很多，关键考虑的核心问题就是连接，数据交互，其他的权限，搜索等都是衍生的关键点也是坑点。下面逐点分析：
     ·1.权限。android6.0以后，蓝牙搜索需要有定位权限ACCESS_COARSE_LOCATION，如果不允许此权限，在6.0以后的系统是搜不到蓝牙设备的。而定位权限是危险权限，需要运行时申请。
     ·2.开启蓝牙功能。在开启之前需要先判断设备是否具有蓝牙功能，如果用户未开启蓝牙需要开启蓝牙功能，有隐式的也有显式的方法，建议显示由用户选择 。
     ·3.搜索。蓝牙自身对于开启设备搜索还是很简单的，只要调用bluetoothAdapter.startDiscovery();而对于搜索结果，则是通过广播的方式接收。
     ·4.配对。蓝牙的配对与连接是两回事，只有配对成功才能建立连接并发送数据。因为配对是隐藏的方法所以需要通过反射的方式进行。配对需要一个配对码，这需在硬件生产的时候初始一个（一般都是"0000"或"1234"）。手机设备之间还需要有个配对码，这个没法跳过。
     ·5.连接。配对成功需要建立连接才能发送数据，连接需要一个uuid（随意一个就行）作为唯一码来识别当前设备与服务端设备的一个连接，而经典蓝牙的连接是通过socket模式建立连接的，只需要以下两句代码即可。
mBlueSocket=mServiceDevice.createRfcommSocketToServiceRecord(UUID);
mBlueSocket.connect();
     ·6.数据交互。连接完成则可以发送数据。可通过rssi信号强度来判断何时发送数据，获取实时rssi可以通过不断扫描获取，也可通过建立gatt连接（但这个更适合用ble场景）。数据发送与接收区分服务端与客户端，这都是相对发送方与接收方而言的，并不固定与设备。因为这涉及到耗时操作，需要在子线程操作.
发送:   os = mBlueSocket .getOutputStream();
          os.write("testMessage".getBytes());
接收： serverSocket = bluetoothAdapter.listenUsingRfcommWithServiceRecord("serverSocket", UUID);
           BluetoothSocket accept = serverSocket.accept();
           is = accept.getInputStream();
注意：因为发送的数据有大小限制，需要自己做对数据的分包与组包，这一块我没做。
     ·7.业务处理。不管出于什么原因做这些研究最后都是为了处理业务，而我是做身份识别，所以就通过传输的数据模拟身份标识，根据不同的数据做相应的响应。
     以上就是简单的经典蓝牙开发的主机主要流程，从机的核心点是被搜索到和时刻监听连接请求并在连接上时做相应的处理，这里就在demo实现了。但是要真正做成产品还有很多细节要处理，包括一对多的问题，搜索与连接的时效性与闭合，数据的分包与组包，业务处理等。因为我自己还是个菜鸟，所以这些问题我有些解决了但不理想，有些根本就不会，所以先埋个坑。不过上面的解决办法都是经典蓝牙的模式，因为经典蓝牙ios不支持，如果想考虑跨设备，必须要用BLE蓝牙模式。接下来就是我新一轮的挖坑历程。

二、BLE蓝牙模式
     BLE (Bluetooth Low Energy) 顾名思义，低功耗蓝牙，是蓝牙4.0之后的核心profile，android4.3+以后才支持。BLE模式引入了两个概念中央设备(central)与外围设备 （peripheral),其中中央设备可以连接多台外围设备，外围设备只能与一个中央设备连接，中央设备也叫主机且是作为C端，外围设备也叫从机是作为S端。C端扫描，只有当S端发出广播信号，C端才能搜索到S端的服务并建立GATT连接。这里是不是很绕，C/S模式跟常识理解的刚好相反。当初我在理解这里的时候也是很痛苦，多看几遍再看看别人写的详细介绍就好了。
     上面提到了服务service，以及GATT连接，gatt连接是ble的连接模式，类似socket连接，只是前者只支持少量数据传输，就我自己测试的时候最大只有20个byte。而服务就是外围设备所提供的服务（例如：手环提供的心跳检测服务），有自己唯一的UUID，且商用的产品uuid是要钱买的。每个服务都是由一个或多个特征Characteristic 和 Descriptor组成的，而Characteristic  又是由value和 Descriptor组成的，这里的value就是我们要传输时用到的，最大20byte. Characteristic有多种属性只读、写、通知。Descriptor顾名思义就是描述，就是个解释说明。
     对上面涉及到的名词如果不理解也是很正常的，因为我也就是以我自己理解的方式记录一下，可能有偏差，最好还是通过看一些专业的文章来加深认识，就是抛砖引玉的作用。
     接下来就是BLE连接的实现，因为BLE模式是通过回调的方式进行搜索和连接，不需要自己监听广播，在工作量上少了很多，但是基本流程还是不变的。以下逐点分析：
中央设备，即C端：
     ·1.权限。android6.0以后，蓝牙搜索需要有定位权限ACCESS_COARSE_LOCATION，如果不允许此权限，在6.0以后的系统是搜不到蓝牙设备的。而定位权限是危险权限，需要运行时申请。
     ·2.开启蓝牙功能。在开启之前需要先判断设备是否具有BLE蓝牙功能，如果用户未开启蓝牙需要开启蓝牙功能，有隐式的也有显式的方法，建议显示由用户选择。
     ·3.搜索。ble蓝牙模式关于搜索有两种方式，一种是bluetoothAdapter.startLeScan(mScanCallback); android4.3以后的，但是此方法已经被官方抛弃，可网上大部分文章还是通过这种方式，包括我demo里引入的框架。另一种方式就是官方推荐的但需要android5.0以后才行，需要进行版本判断：bluetoothAdapter.getBluetoothLeScanner().startScan(mLeScanCallback); 不管是哪一种搜索结果都是放到回调里面处理。
     ·4.建立GATT连接。搜索结果里的ScanResult里的scanRecord可以获取到设备提供的service及其对应的characteristic的UUID，可以根据service过滤掉不符合的设备，对满足的设备只需调用bluetoothDevice.connectGatt(context, false, bluetoothGattCallback)即可，结果都是在回调中处理，回调中的方法是异步的，有先后顺序。
     ·5.获取characteristic。获取相应的特征（读、写、通知），根据特征拥有的属性执行相应的操作，例如拥有写动作的特征可以发送数据，拥有通知属性的特征可以设置通知告知外围设备可以发送数据等。
     ·6.数据交互。如果是通过通知的形式不需要传输数据到S端，只要在合适的时候触发通知（ios我暂时只能以通知的方式交互），令S端接收到指令，要求S端进行响应即可：bluetoothGatt.setCharacteristicNotification(characteristic4Read, true);
需要发送数据则可以通过以下方式：characteristic4Write.setValue(msg);
                                                          bluetoothGatt.writeCharacteristic(characteristic4Write);
数据的接收都是在4提到的回调中的onCharacteristicChanged（...）进行处理。
注意：不管是通知还是write，其一次所能传输的数据大小就是20个byte,不知道为什么ios的通知可以传155个byte，也许是我的能力有限，理解有误。
     ·7.业务处理。根据自身业务处理，而我是做身份识别，所以就通过传输的数据模拟身份标识，根据不同的数据做相应的响应。

外围设备，即S端：
     ·1.开启蓝牙，检测是否支持BLE蓝牙，版本要求,可被检测时间。这些都是标配，不细说了，代码有解释。
     ·2.开启广播。BLE模式的S端通过bluetoothLeAdvertiser.startAdvertising（）来开启广播，只有开启了才能被中央设备检测到，这一定要闭合（页面/应用关闭时，调用stopAdvertising）,因为这是系统级别的广播并不仅仅跟随应用，而且只能并存4次（可能有误）。
     ·3.启动服务及其特征characteristic。bl在广播启动成功的时候需要启动服务与设置其特征，否则C端无法进行数据交互。其中在设置特征的时候涉及到特征的作用以及权限问题，需要额外的了解。
     ·4.数据交互。S端都是通过notifyCharacteristicChanged()来向中央设备响应数据的，不管C端发送的信号是通知还是write过来。数据的携带者都是特征，大小20byte.

     以上就是简单的BLE蓝牙模式，除了连接模式不一样，其实流程与经典蓝牙模式都是差不多的，只是需要明确中央设备与外围设备的定位就行。我的demo有引入第三方框架，也有自己用的原生，前者搜索快，可以保持跨设备的连接状态，封装了重连等，有很多优势，唯一遗憾是用了sdk遗弃的搜索方法。
     感谢：
               https://github.com/hnlbxb2004/BluetoothSocket
               https://github.com/xiaoyaoyou1212/BLE


     以及其他在我学习路上看到的文章的贡献者。

activity说明：
BluetoothClientActivity:           为经典蓝牙的C端，用了第三方sdk，但是不理想，还有很多路走。
BluetoothEDPServerActivity:  为经典蓝牙的S端，简单的实现。这两个类可以实现android之间一对一的蓝牙交互。

BluetoothBLEClientActivity： 纯粹是我自己一步一步学习的过程的产出，为了熟悉每个方法的作用。
BluetoothBLEForClientActivity：在完全使用原生提供的方法实现的，于ios连接方面不理想。
BLEActivity：借助第三方框架实现的，相对来说已经很理想了。
BluetoothBleServerActivity：外围设备即S端的实现。
